if (typeof GeneCore === 'undefined') {
  var GeneCore = {};
}

GeneCore.promises = {};
GeneCore.properties = {};
GeneCore.utils = {};

if (!String.prototype.includes) {
  String.prototype.includes = function () {
    'use strict';
    return String.prototype.indexOf.apply(this, arguments) !== -1;
  };
}

//https://tc39.github.io/ecma262/#sec-array.prototype.includes
if (!Array.prototype.includes) {
  Object.defineProperty(Array.prototype, 'includes', {
    value: function (searchElement, fromIndex) {
      if (this == null) {
        throw new TypeError('"this" is null or not defined');
      }

      // 1. Let O be ? ToObject(this value).
      var o = Object(this);

      // 2. Let len be ? ToLength(? Get(O, "length")).
      var len = o.length >>> 0;

      // 3. If len is 0, return false.
      if (len === 0) {
        return false;
      }

      // 4. Let n be ? ToInteger(fromIndex).
      //    (If fromIndex is undefined, this step produces the value 0.)
      var n = fromIndex | 0;

      // 5. If n ≥ 0, then
      //  a. Let k be n.
      // 6. Else n < 0,
      //  a. Let k be len + n.
      //  b. If k < 0, let k be 0.
      var k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);

      function sameValueZero(x, y) {
        return (
          x === y ||
          (typeof x === 'number' &&
            typeof y === 'number' &&
            isNaN(x) &&
            isNaN(y))
        );
      }

      // 7. Repeat, while k < len
      while (k < len) {
        // a. Let elementK be the result of ? Get(O, ! ToString(k)).
        // b. If SameValueZero(searchElement, elementK) is true, return true.
        if (sameValueZero(o[k], searchElement)) {
          return true;
        }
        // c. Increase k by 1.
        k++;
      }

      // 8. Return false
      return false;
    },
  });
}

if (!Array.prototype.fill) {
  var fill = function (value) {
    // Steps 1-2.
    if (this == null) {
      throw new TypeError('this is null or not defined');
    }

    var O = Object(this);

    // Steps 3-5.
    var len = O.length >>> 0;

    // Steps 6-7.
    var start = arguments[1];
    var relativeStart = start >> 0;

    // Step 8.
    var k =
      relativeStart < 0
        ? Math.max(len + relativeStart, 0)
        : Math.min(relativeStart, len);

    // Steps 9-10.
    var end = arguments[2];
    var relativeEnd = end === undefined ? len : end >> 0;

    // Step 11.
    var last =
      relativeEnd < 0
        ? Math.max(len + relativeEnd, 0)
        : Math.min(relativeEnd, len);

    // Step 12.
    while (k < last) {
      O[k] = value;
      k++;
    }

    // Step 13.
    return O;
  };

  if (Object.defineProperty) {
    try {
      Object.defineProperty(Array.prototype, 'fill', {
        value: fill,
        configurable: true,
        enumerable: false,
        writable: true,
      });
    } catch (e) {}
  }

  Array.prototype.fill = fill;
}

if (!String.prototype.startsWith) {
  Object.defineProperty(String.prototype, 'startsWith', {
    value: function (search, rawPos) {
      var pos = rawPos > 0 ? rawPos | 0 : 0;
      return this.substring(pos, pos + search.length) === search;
    },
  });
}

//HTMLDocument.ie9 (Internet Explorer 9)
if (!this.HTMLDocument) {
  this.HTMLDocument = this.Document;
}

/**
 * Element.matches()
 * https://developer.mozilla.org/enUS/docs/Web/API/Element/matches#Polyfill
 */
if (!Element.prototype.matches) {
  Element.prototype.matches =
    Element.prototype.msMatchesSelector ||
    Element.prototype.webkitMatchesSelector;
}

// eslint-disable-next-line valid-jsdoc
/**
 * Element.closest()
 * https://developer.mozilla.org/enUS/docs/Web/API/Element/closest#Polyfill
 */
if (!Element.prototype.closest) {
  Element.prototype.closest = function (s) {
    'use strict';
    var el = this;
    if (!document.documentElement.contains(el)) {
      return null;
    }
    do {
      if (el.matches(s)) {
        return el;
      }
      el = el.parentElement || el.parentNode;
    } while (el !== null && el.nodeType === 1);
    return null;
  };
}

//this support IE 11
if (!String.prototype.startsWith) {
  String.prototype.startsWith = function (searchString, position) {
    return this.substr(position || 0, searchString.length) === searchString;
  };
}

//https://tc39.github.io/ecma262/#sec-array.prototype.find
if (!Array.prototype.find) {
  Object.defineProperty(Array.prototype, 'find', {
    value: function (predicate) {
      // 1. Let O be ? ToObject(this value).
      if (this == null) {
        throw TypeError('"this" is null or not defined');
      }

      var o = Object(this);

      // 2. Let len be ? ToLength(? Get(O, "length")).
      var len = o.length >>> 0;

      // 3. If IsCallable(predicate) is false, throw a TypeError exception.
      if (typeof predicate !== 'function') {
        throw TypeError('predicate must be a function');
      }

      // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.
      var thisArg = arguments[1];

      // 5. Let k be 0.
      var k = 0;

      // 6. Repeat, while k < len
      while (k < len) {
        // a. Let Pk be ! ToString(k).
        // b. Let kValue be ? Get(O, Pk).
        // c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).
        // d. If testResult is true, return kValue.
        var kValue = o[k];
        if (predicate.call(thisArg, kValue, k, o)) {
          return kValue;
        }
        // e. Increase k by 1.
        k++;
      }

      // 7. Return undefined.
      return undefined;
    },
    configurable: true,
    writable: true,
  });
}

$.fn.optimizedImage = function () {
  var $el = $(this),
    thisIdSelector = '#' + $el.attr('id');
  //options
  var isBackgroundImage = $el.prop('nodeName') != 'IMG',
    placeholderImage = $el.attr('src');
  (sources = $el.data('optimg-srcset')),
    (initialWidth = $el.data('optimg-init-width')),
    (fixedWidth = $el[0].hasAttribute(' fixed'));
  isFirstLoad = true;
  //instance variables
  var requestWidth,
    srcSet = [null, null, null],
    smallMediaQuery = window.matchMedia('(max-width: 749px)'),
    mediumMediaQuery = window.matchMedia(
      '(min-width: 750px) and (max-width: 991px)'
    ),
    largeMediaQuery = window.matchMedia('(min-width: 992px)');

  init();

  function init() {
    if (Array.isArray(sources)) {
      srcSet = sources;
      srcSet[1] = srcSet[1] || srcSet[0];
      srcSet[2] = srcSet[2] || srcSet[1] || srcSet[0];
    } else if (sources) {
      srcSet.fill(sources);
    } else {
      return;
    }

    if (!fixedWidth) {
      smallMediaQuery.addListener(updateImageSource);
      mediumMediaQuery.addListener(updateImageSource);

      $(window).on('resize', _.throttle(updateImageSource, 200));
    }

    updateImageSource();
  }

  var lastBreakpoint;
  var breakpointRequestProcessing = false;

  function updateImageSource() {
    if (breakpointRequestProcessing) {
      return false;
    }

    var imageSrc;
    var currentBreakpoint;

    if (smallMediaQuery.matches) {
      imageSrc = srcSet[0];
      currentBreakpoint = 'sm';
    } else if (mediumMediaQuery.matches) {
      imageSrc = srcSet[1];
      currentBreakpoint = 'md';
    } else {
      imageSrc = srcSet[2];
      currentBreakpoint = 'lg';
    }

    //In case authored image is smaller than its container allows in the new breakpoint,
    //we use our placeholder image (1400px x 1px transparent) to push to that new max-width
    //before measuring and requesting new image size.
    if (
      lastBreakpoint != currentBreakpoint &&
      !isBackgroundImage &&
      !isFirstLoad
    ) {
      //this is a throttled function that may be called repeatedly. This boolean prevents another call
      //until we've swappend and measured placeholder
      breakpointRequestProcessing = true;
      lastBreakpoint = currentBreakpoint;

      $el.one('load', function () {
        setImage(imageSrc);
        breakpointRequestProcessing = false;
      });
      $el.attr('src', placeholderImage);
    } else {
      setImage(imageSrc);
    }
  }

  function setImage(imageSrc) {
    setRequestWidth();
    imageSrc = addSelector(imageSrc, requestWidth);
    setSrcValue(imageSrc);
  }

  function setSrcValue(imageSrc) {
    var currentSrc = '';

    if (isBackgroundImage) {
      currentSrc = $el.css('background-image');
    } else {
      currentSrc = $el.attr('src');
    }
    if (!currentSrc || !currentSrc.includes(imageSrc)) {
      if (isBackgroundImage) {
        $el.css('background-image', 'url(' + imageSrc + ')');
      } else {
        $el.one('load', function () {
          //force UI update on components like Safety Bar which are affected by content height
          $(window).trigger('scroll');
        });
        $el.attr('src', imageSrc);
      }
    }
    isFirstLoad = false;
  }

  function addSelector(srcString, width) {
    var lastIndex = srcString.lastIndexOf('.');

    return (
      srcString.substr(0, lastIndex) +
      '.genecoreimg.' +
      width +
      srcString.substr(lastIndex)
    );
  }

  function setRequestWidth() {
    var sizes = [120, 240, 320, 480, 750, 992, 1200, 1440, 1920];

    if (initialWidth) {
      //use the value on first load
      var renderedWidth = initialWidth;
      initialWidth = null;
    } else {
      if ($el.is(':visible')) {
        renderedWidth = $el.outerWidth();
      } else {
        renderedWidth = $el.actual('width');
      }
    }

    var closest = Math.max.apply(null, sizes); //Get the highest number in arr in case it match nothing.
    for (var i = 0; i < sizes.length; i++) {
      //Loop the array
      if (sizes[i] >= renderedWidth && sizes[i] < closest) closest = sizes[i];
    }

    requestWidth = closest;
  }
};

$(document).ready(function () {
  $('[ srcset]').each(function () {
    $(this).optimizedImage();
  });
});

var observer = new MutationSummary({
  callback: function (changes) {
    changes.forEach(function (change) {
      change.added.forEach(function (el) {
        $(el).optimizedImage();
      });
    });
  },
  queries: [{ element: '*[ srcset]' }],
  rootNode: document.getElementsByClassName('basicpage')[0],
});

//including this library for .actual() function used to determine width of invisible
//elements in the DOM
(function (factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register module depending on jQuery using requirejs define.
    define(['jquery'], factory);
  } else {
    // No AMD.
    factory(jQuery);
  }
})(function ($) {
  $.fn.addBack = $.fn.addBack || $.fn.andSelf;

  $.fn.extend({
    actual: function (method, options) {
      // check if the jQuery method exist
      if (!this[method]) {
        throw (
          '$.actual => The jQuery method "' +
          method +
          '" you called does not exist'
        );
      }

      var defaults = {
        absolute: false,
        clone: false,
        includeMargin: false,
        display: 'block',
      };

      var configs = $.extend(defaults, options);

      var $target = this.eq(0);
      var fix, restore;

      if (configs.clone === true) {
        fix = function () {
          var style = 'position: absolute !important; top: -1000 !important; ';

          // this is useful with css3pie
          $target = $target.clone().attr('style', style).appendTo('body');
        };

        restore = function () {
          // remove DOM element after getting the width
          $target.remove();
        };
      } else {
        var tmp = [];
        var style = '';
        var $hidden;

        fix = function () {
          // get all hidden parents
          $hidden = $target.parents().addBack().filter(':hidden');
          style +=
            'visibility: hidden !important; display: ' +
            configs.display +
            ' !important; ';

          if (configs.absolute === true)
            style += 'position: absolute !important; ';

          // save the origin style props
          // set the hidden el css to be got the actual value later
          $hidden.each(function () {
            // Save original style. If no style was set, attr() returns undefined
            var $this = $(this);
            var thisStyle = $this.attr('style');

            tmp.push(thisStyle);
            // Retain as much of the original style as possible, if there is one
            $this.attr('style', thisStyle ? thisStyle + ';' + style : style);
          });
        };

        restore = function () {
          // restore origin style values
          $hidden.each(function (i) {
            var $this = $(this);
            var _tmp = tmp[i];

            if (_tmp === undefined) {
              $this.removeAttr('style');
            } else {
              $this.attr('style', _tmp);
            }
          });
        };
      }

      fix();
      // get the actual value with user specific methed
      // it can be 'width', 'height', 'outerWidth', 'innerWidth'... etc
      // configs.includeMargin only works for 'outerWidth' and 'outerHeight'
      var actual = /(outer)/.test(method)
        ? $target[method](configs.includeMargin)
        : $target[method]();

      restore();
      // IMPORTANT, this plugin only return the value of the first element
      return actual;
    },
  });
});

/******************************************************
 * Serializes data within a form element.
 * Usage:
 *    var data = $('#my-form').serializeObject();
 *******************************************************/

$.fn.serializeObject = function (form) {
  var results = {},
    arr = this.serializeArray();
  for (var i = 0, len = arr.length; i < len; i++) {
    obj = arr[i];
    //Check if results have a property with given name
    if (results.hasOwnProperty(obj.name)) {
      //Check if given object is an array
      if (!results[obj.name].push) {
        results[obj.name] = [results[obj.name]];
      }
      results[obj.name].push(obj.value || '');
    } else {
      results[obj.name] = obj.value || '';
    }
  }
  return results;
};

var sessionUtils = {
  _id: null,
  _cookieCache: undefined,
  _init: function () {
    if (!window.name) {
      window.name = Math.random();
    }
    this._id = window.name;
    this._initCache();

    // See if we've changed protcols
    var matches = new RegExp(this._generatePrefix() + '=([^;]+);').exec(
      document.cookie
    );
    if (matches && document.location.protocol !== matches[1]) {
      this._clearSession();
      for (var key in this._cookieCache) {
        try {
          if (this._cookieCache.hasOwnProperty(key)) {
            window.sessionStorage.setItem(key, this._cookieCache[key]);
          }
        } catch (e) {
          console.error(e);
        }
      }
    }
    document.cookie =
      this._generatePrefix() +
      '=' +
      document.location.protocol +
      ';path=/;expires=' +
      new Date(new Date().getTime() + 120000).toUTCString();
  },
  _generatePrefix: function () {
    return '__session:' + this._id + ':';
  },
  _initCache: function () {
    var cookies = document.cookie.split(';');
    this._cookieCache = {};
    var self = this;
    cookies.forEach(function (cookie) {
      var kv = cookie.split('=');
      if (new RegExp(self._generatePrefix() + '.+').test(kv[0]) && kv[1]) {
        self._cookieCache[kv[0].split(':', 3)[2]] = kv[1];
      }
    });
  },
  _setFallback: function (key, value) {
    var cookie = this._generatePrefix() + key + '=' + value + '; path=/';
    //set expiration for 15 minutes from now
    cookie += '; expires=' + new Date(Date.now() + 900000).toUTCString();
    document.cookie = cookie;
    this._cookieCache[key] = value;
    return this;
  },

  _getFallback: function (key) {
    if (!this._cookieCache) {
      this._initCache();
    }
    return this._cookieCache[key];
  },

  _clearFallback: function () {
    for (var i in this._cookieCache) {
      document.cookie =
        this._generatePrefix() +
        i +
        '=; path=/; expires=Thu, 01 Jan 1970 00:00:01 GMT;';
    }
    this._cookieCache = {};
  },

  _deleteFallback: function (key) {
    document.cookie =
      this._generatePrefix() +
      key +
      '=; path=/; expires=Thu, 01 Jan 1970 00:00:01 GMT;';
    delete this._cookieCache[key];
  },
  get: function (key) {
    return window.sessionStorage.getItem(key) || this._getFallback(key);
  },
  //cookieFallBack == true will persist data in a cookie for 15 minutes which allows
  //    sharing of session data between tabs
  set: function (key, value, cookieFallback) {
    try {
      window.sessionStorage.setItem(key, value);
    } catch (e) {}
    if (cookieFallback) {
      this._setFallback(key, value);
    }
    return this;
  },
  del: function (key) {
    return this.remove(key);
  },
  remove: function (key) {
    try {
      window.sessionStorage.removeItem(key);
    } catch (e) {
      console.error(e);
    }
    this._deleteFallback(key);
    return this;
  },
  _clearSession: function () {
    try {
      window.sessionStorage.clear();
    } catch (e) {
      for (var i in window.sessionStorage) {
        window.sessionStorage.removeItem(i);
      }
    }
  },
  clear: function () {
    this._clearSession();
    this._clearFallback();
    return this;
  },
};
sessionUtils._init();

/******************************************************
 * Checks if an element is visible in the current viewport
 * Usage:
 *    $('#my-form').isInViewport(); // true,false
 *******************************************************/

$.fn.isInViewport = function () {
  let elementTop = $(this).offset().top;
  let elementBottom = elementTop + $(this).outerHeight();

  let viewportTop = $(window).scrollTop();
  let viewportBottom = viewportTop + $(window).height();

  return elementBottom > viewportTop && elementTop < viewportBottom;
};
$.widget('gene.genePrint', {
  _create: function () {
    this.targetSelector = this.element.data('print-selector') || 'all';
    this.noPrintSelector = this.element.data('print-exclude') || '';

    // prevent anchors to fire if they are sent to print
    if (this.element.is('a')) {
      this.element.attr('href', '#');
      this.element.click(function (e) {
        e.preventDefault();
      });
    }
    this._initializePrint();
  },
  _initializePrint: function () {
    $(this.element).on('click', $.proxy(this._printHandler, this));
  },
  _printHandler: function () {
    if (this.targetSelector == 'all') {
      if (this.noPrintSelector) {
        $.print({
          noPrintSelector: this.noPrintSelector,
        });
      } else {
        // this will just call the native print
        // when noPrintSelector is missing.
        window.print();
      }
    } else {
      $(this.targetSelector).print({
        noPrintSelector: this.noPrintSelector,
      });
    }
  },
});

(function ($) {
  //Initialize Tooltip widgets
  $('.gene-print').each(function () {
    $(this).genePrint();
  });
})(jQuery);

$.widget('gene.geneTooltip', {
  _create: function () {
    this.$tooltipContent = this._getTooltipContent();
    this.opened = false;
    this.side = null;

    if (this.$tooltipContent) {
      if (this.element.is('a')) {
        this.element.attr('href', '#');
        this.element.click(function (e) {
          e.preventDefault();
        });
      }

      this.saftyBarElement = $('.cmp-safetybar');
      $(window).on('safetybar:resize', $.proxy(this._resizeHandler, this));
      $(window).on(
        'breakpoint-change',
        $.proxy(this._breakpointChangeHandler, this)
      );
      $(window).on('tooltip:open', $.proxy(this._tooltipOpenHandler, this));
      $(window).on('modal:show', $.proxy(this._tooltipOpenHandler, this));
      $(window).on('modal:hide', $.proxy(this._tooltipOpenHandler, this));

      this._initializeTooltip();
    }
  },

  _getTooltipContent: function () {
    var $tooltipContentTemplate = $('#tooltip-template').clone(),
      $header = $tooltipContentTemplate.find('.cmp-tooltip__header'),
      $body = $tooltipContentTemplate.find('.cmp-tooltip__body');

    if (this.options.content !== undefined) {
      $body.html(this.options.content);

      if (this.options.title !== undefined) {
        var title = this.options.originalTerm
          ? this.options.originalTerm
          : this.options.title;
        $header.html($('<strong></strong>').html(title));
      }
    } else {
      if (this.element.data('content')) {
        $body.html($.parseHTML(this.element.data('content')));
      }
    }

    if ($header.is(':empty')) {
      $header.remove();
    }

    return $tooltipContentTemplate || null;
  },

  _initializeTooltip: function () {
    this.element.tooltipster({
      trigger: 'custom',
      theme: [
        'tooltipster-genentechcore',
        'tooltipster-genentechcore-customized',
      ],
      content: this.$tooltipContent,
      side: ['top', 'bottom'],
      zIndex: 90,
      triggerOpen: {
        click: true,
        tap: true,
      },
      functionAfter: $.proxy(this._closeHandler, this),
      functionPosition: $.proxy(this._positionHandler, this),
      functionReady: $.proxy(this._modalHandler, this),
      arrow: !this.element.is('IMG'),
    });

    this.tooltipInstance = this.element.tooltipster('instance');

    this.tooltipInstance.on('ready', $.proxy(this._openHandler, this));
  },

  _modalHandler: function (instance, helper, props) {
    //first check for external link class
    $(instance.__Content)
      .find('.external-link-indicator')
      .on('click', function (e) {
        //if we have a modal configured fire it
        var $exitModal = $('.third-part-modal.exit-modal .cmp-modal');
        if ($exitModal) {
          e.preventDefault();
          e.stopPropagation();
          var href = $(this).attr('href');
          var target = $(this).attr('target') || '_self';

          // Checks if the user wants to open the link in a new tab
          if (
            e.ctrlKey ||
            e.shiftKey ||
            e.metaKey || // apple
            (e.button && e.button == 1) // middle click, >IE9 + everyone else
          ) {
            target = '_blank';
          }

          $exitModal
            .find('.cmp-modal__button--confirm')
            .attr({ href: href, target: target });
          $exitModal.modal('show');
        }
      });
  },

  _positionHandler: function (instance, helper, position) {
    this.side = position.side;

    if (GeneCore.utils.resizeUtil.getCurrentBreakpoint() != 'xs') {
      position.size.height =
        $(helper.tooltipClone).find('.tooltipster-content').outerHeight() + 10;
      if (position.side == 'top') {
        position.coord.top =
          helper.geo.origin.windowOffset.top -
          position.size.height +
          (this.element.is('IMG') ? $(this.element).height() - 10 : 0);
      } else {
        position.coord.top += this.element.is('IMG')
          ? $(this.element).height() - 10
          : 0;
      }
    }

    return position;
  },

  _checkPosition: function () {
    if (GeneCore.utils.resizeUtil.getCurrentBreakpoint() != 'xs') {
      if (this.opened && this.side == 'top') {
        var elementTop = this.element.offset().top;
        if (
          elementTop <
          window.pageYOffset + (GeneCore.properties.stickyMastheadHeight || 0)
        ) {
          this._hide();
        }
      }
    }
  },

  _tooltipOpenHandler: function (event, openedIntanceId) {
    if (this.tooltipInstanceId != openedIntanceId) {
      this._hide();
    }
  },

  _breakpointChangeHandler: function (e, breakpoint) {
    $(window).off('resize.cmp-tooltip scroll.cmp-tooltip');

    if (breakpoint == 'xs' || breakpoint == 'md') {
      if (GeneCore.properties.isMastheadStickyEnabledMobile) {
        // Position should be checked only if the masthead sticky option is enabled
        $(window).on(
          'resize.tooltipster-base',
          _.throttle($.proxy(this._checkPosition, this), 50)
        );
        $(window).on(
          'scroll.tooltipster-base',
          _.throttle($.proxy(this._checkPosition, this), 10)
        );
      }
    } else {
      if (GeneCore.properties.isMastheadStickyEnabledDesktop) {
        // Position should be checked only if the masthead sticky option is enabled
        $(window).on(
          'resize.tooltipster-base',
          _.throttle($.proxy(this._checkPosition, this), 50)
        );
        $(window).on(
          'scroll.tooltipster-base',
          _.throttle($.proxy(this._checkPosition, this), 10)
        );
      }
    }
  },

  _hide: function () {
    this.element.tooltipster('hide');
    $(this.element.tooltipster('elementTooltip'))
      .find('.external-link-indicator')
      .off('click');
  },

  _openHandler: function (event) {
    this.opened = true;

    var $tooltipContainer = $(this.element.tooltipster('elementTooltip'));

    var _this = this;
    $tooltipContainer.find('.cmp-tooltip__close').click(function () {
      _this._hide();
    });

    var saftyBarHeight = this.saftyBarElement.safetyBar('getHeight');
    var isSaftyBarSticky = this.saftyBarElement.safetyBar('isSaftyBarSticky');

    if (isSaftyBarSticky) {
      $tooltipContainer.css('bottom', saftyBarHeight + 'px');
    } else {
      $tooltipContainer.css('bottom', 0);
    }
    this.tooltipInstanceId = $tooltipContainer.attr('id');
    $(window).trigger('tooltip:open', this.tooltipInstanceId);
  },

  _closeHandler: function () {
    this.opened = false;
  },

  _resizeHandler: function (event, saftyBarArgs) {
    if (this.opened) {
      var $tooltipContainer = $(this.element.tooltipster('elementTooltip'));
      if (saftyBarArgs.isSticky) {
        $tooltipContainer.css('bottom', saftyBarArgs.height + 'px');
      } else {
        $tooltipContainer.css('bottom', 0);
      }
    }
  },
});

(function ($) {
  //Initialize Tooltip widgets
  $('[data-tooltip-content]').each(function () {
    var $this = $(this);

    $this.geneTooltip({
      title: $this.data('tooltip-title'),
      content: $this.data('tooltip-content'),
    });
  });
})(jQuery);

GeneCore.utils.generalUtils = {
  getUrlHash: function () {
    var urlHash = window.location.hash.substring(1);
    if (urlHash.includes('?')) {
      urlHash = urlHash.split('?')[0];
    }
    return urlHash;
  },
  getUrlParam: function (paramName) {
    var urlparameter = null;
    if (window.location.href.indexOf(paramName) > -1) {
      urlparameter = this.getUrlVars()[paramName];
    }
    return urlparameter;
  },
  getUrlVars: function () {
    var vars = {};
    var parts = window.location.href.replace(
      /[?&]+([^=&]+)=([^&]*)/gi,
      function (m, key, value) {
        vars[key] = value;
      }
    );
    return vars;
  },
  removeTags: function (str) {
    if (str === null || str === '') {
      return false;
    } else {
      str = str.toString();
      return str.replace(/(<([^>]+)>)/gi, '').trim();
    }
  },
  addUrlParam: function (url, param) {
    return url + (url.indexOf('?') != -1 ? '&' + param : '?' + param);
  },
  toggleBodyOverflow: function () {
    if (!$('body').hasClass('body-modal-active')) {
      var scrollWidth = window.innerWidth - $(document).width();
      $('body').addClass('body-modal-active');
      $('html').css('padding-right', scrollWidth);
      $('.is-sticky.sticky-full-width').css('margin-right', scrollWidth);
    } else {
      $('body').removeClass('body-modal-active');
      $('html').css('padding-right', '');
      $('.is-sticky.sticky-full-width').css('margin-right', '');
    }
  },
  filterNullOrEmpty: function (obj) {
    try {
      $.each(obj, function (key, value) {
        if (value === '' || value === null) {
          delete obj[key];
        } else if (
          Object.prototype.toString.call(value) === '[object Object]'
        ) {
          GeneCore.utils.generalUtils.filterNullOrEmpty(value);
        } else if (Array.isArray(value)) {
          value.forEach(function (el) {
            GeneCore.utils.generalUtils.filterNullOrEmpty(el);
          });
        }
      });
      return obj;
    } catch (err) {
      return obj;
    }
  },
};

$.fn.breakpoint = function () {
  //instance variables
  var beforeElement = window.getComputedStyle
      ? window.getComputedStyle(document.body, ':before')
      : false,
    currentBreakpoint = '',
    lastBreakpoint = '';

  this.init = function () {
    $(window).on(
      'resize orientationchange load',
      $.proxy(this._onResizeHandler, this)
    );
    return this;
  };

  this._onResizeHandler = function () {
    currentBreakpoint = beforeElement
      .getPropertyValue('content')
      .replace(/\"/g, '');

    if (currentBreakpoint !== lastBreakpoint) {
      $(window).trigger('breakpoint-change', currentBreakpoint);
      lastBreakpoint = currentBreakpoint;
    }
  };

  this.getCurrentBreakpoint = function () {
    return currentBreakpoint;
  };

  this.init();

  return {
    getCurrentBreakpoint: this.getCurrentBreakpoint,
  };
};

GeneCore.utils.resizeUtil = $(window).breakpoint();

GeneCore.utils.cookieUtils = {
  setCookie: function (name, value, days) {
    if (days) {
      var date = new Date();
      date.setTime(date.getTime() + days * 24 * 60 * 60 * 1000);
      var expires = '; expires=' + date.toGMTString();
    } else var expires = '';
    document.cookie = name + '=' + value + expires + '; path=/';
  },

  getCookie: function (name) {
    var nameEQ = name + '=';
    var ca = document.cookie.split(';');
    for (var i = 0; i < ca.length; i++) {
      var c = ca[i];
      while (c.charAt(0) == ' ') c = c.substring(1, c.length);
      if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);
    }
    return null;
  },

  deleteCookie: function (name) {
    this.setCookie(name, '', -1);
  },
};
/**
 * Prevent body scroll and overscroll.
 * Tested on mac, iOS chrome / Safari, Android Chrome.
 *
 * Based on: https://benfrain.com/preventing-body-scroll-for-modals-in-ios/
 *           https://stackoverflow.com/a/41601290
 *
 * Use in combination with:
 * html, body {overflow: hidden;}
 *
 * and: -webkit-overflow-scrolling: touch; for the element that should scroll.
 *
 * disableBodyScroll(true, '.i-can-scroll');
 */
var disableBodyScroll = (function () {
  /**
   * Private variables
   */
  var _selector = false,
    _element = false,
    _clientY;

  /**
   * Prevent default unless within _selector
   *
   * @param  event object event
   * @return void
   */
  var preventBodyScroll = function (event) {
    if (false === _element || !event.target.closest(_selector)) {
      event.preventDefault();
    }
  };

  /**
   * Cache the clientY co-ordinates for
   * comparison
   *
   * @param  event object event
   * @return void
   */
  var captureClientY = function (event) {
    // only respond to a single touch
    if (event.targetTouches.length === 1) {
      _clientY = event.targetTouches[0].clientY;
    }
  };

  /**
   * Detect whether the element is at the top
   * or the bottom of their scroll and prevent
   * the user from scrolling beyond
   *
   * @param  event object event
   * @return void
   */
  var preventOverscroll = function (event) {
    // only respond to a single touch
    if (event.targetTouches.length !== 1) {
      return;
    }

    var clientY = event.targetTouches[0].clientY - _clientY;

    // The element at the top of its scroll,
    // and the user scrolls down
    if (_element.scrollTop === 0 && clientY > 0) {
      if (event.cancelable) {
        event.preventDefault();
      }
    }

    // The element at the bottom of its scroll,
    // and the user scrolls up
    // https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollHeight#Problems_and_solutions
    if (
      _element.scrollHeight - _element.scrollTop <= _element.clientHeight &&
      clientY < 0
    ) {
      if (event.cancelable) {
        event.preventDefault();
      }
    }
  };

  /**
   * Disable body scroll. Scrolling with the selector is
   * allowed if a selector is porvided.
   *
   * @param  boolean allow
   * @param  string selector Selector to element to change scroll permission
   * @return void
   */
  return function (allow, selector) {
    if (typeof selector !== 'undefined') {
      _selector = selector;
      _element = document.querySelector(selector);
    }

    if (true === allow) {
      if (false !== _element) {
        _element.addEventListener('touchstart', captureClientY, false);
        _element.addEventListener('touchmove', preventOverscroll, false);
      }
      document.body.addEventListener('touchmove', preventBodyScroll, false);
    } else {
      if (false !== _element) {
        _element.removeEventListener('touchstart', captureClientY, false);
        _element.removeEventListener('touchmove', preventOverscroll, false);
      }
      document.body.removeEventListener('touchmove', preventBodyScroll, false);
    }
  };
})();

$.fn.scrollDirection = function () {
  var $el = $(this);

  // initialize last scroll position
  var lastY = $el.scrollTop();
  var lastX = $el.scrollLeft();
  var prevDirection = 'none';
  var currentDirection = 'none';

  init();

  function init() {
    // Scroll & resize events
    $(window).on('scroll resize', scrollHandler);
  }

  function scrollHandler() {
    // get current scroll position
    var currY = $el.scrollTop(),
      currX = $el.scrollLeft();

    if (currY > lastY + 5) {
      y = 'down';
      lastY = currY;
      $el.trigger('scroll-direction-change', y);
    } else if (currY < lastY - 5) {
      y = 'up';
      lastY = currY;
      $el.trigger('scroll-direction-change', y);
    }
  }
};

$(document).ready(function () {
  $(window).scrollDirection();
});

GeneCore.promises.mastheadReadyPromise = $.Deferred();

$.fn.anchorsUtil = function () {
  this.init = function () {
    var urlHash = GeneCore.utils.generalUtils.getUrlHash();
    if (
      urlHash &&
      !urlHash.startsWith('tab') &&
      !urlHash.startsWith('accordion')
    ) {
      GeneCore.promises.mastheadReadyPromise.done(function () {
        GeneCore.utils.anchorsUtil.scrollToAnchor(urlHash, null, true);
        $('.cmp-safetybar').safetyBar('checkPosition');
      });
    }

    // If an anchor link is clicked, scroll to anchor
    $("a[href^='#']:not(.skip-anchor)").mousedown(function (event) {
      if (event.which == 1) {
        handleAnchor(event, false);
      }
    });

    $("a[href^='#']:not(.skip-anchor)").keydown(function (event) {
      var keycode = event.keyCode ? event.keyCode : event.which;
      if (keycode == 13) {
        handleAnchor(event, true);
      }
    });

    return this;
  };
  // Function to find & return the anchor
  function findAnchor(target) {
    if (!target.includes('#')) {
      target = '#' + target;
    }
    return $(target);
  }

  function handleAnchor(event, isKeyboard) {
    var hash = $(event.target).closest('a').prop('hash');
    if (hash && hash != '#') {
      // find if this inside ISI
      if (includes('.cmp-safetybar .is-sticky', hash)) {
        $('.cmp-safetybar')
          .find('.cmp-safetybar__sticky-wrapper')
          .removeClass('is-sticky');
      }
      GeneCore.utils.anchorsUtil.scrollToAnchor(hash, event, false, isKeyboard);
    }
  }

  function includes(pElement, cElement) {
    return $(pElement).find(cElement).length > 0;
  }

  // Function to scroll to the anchor
  this.scrollToAnchor = function (
    targetId,
    event,
    immediate,
    setFocus,
    timeInMs
  ) {
    var $scrollTarget = findAnchor(targetId);
    // only try to scroll if we find an anchor
    if ($scrollTarget.length) {
      if (event) {
        event.preventDefault();
      }
      var targetTopOffset = $scrollTarget.offset().top;
      this.scrollToYPosition(targetTopOffset, immediate, timeInMs);
      if (
        GeneCore.utils.generalUtils.getUrlHash() != targetId &&
        !targetId.includes('#')
      ) {
        // set the hash when updated
        window.location.hash = '#' + targetId;
      }
      if (setFocus) {
        if ($scrollTarget.prop('tabindex') >= 0) {
          $scrollTarget.focus();
        } else {
          $scrollTarget.find(':tabbable').first().focus();
        }
      }
    }
  };

  this.scrollToYPosition = function (yPosition, immediate, timeInMs) {
    var animateTime = timeInMs || 600;
    GeneCore.promises.mastheadReadyPromise.done(function () {
      var adjustedTopPosition =
        yPosition - (GeneCore.properties.stickyMastheadHeight || 0);
      if (immediate) {
        $('html, body').scrollTop(adjustedTopPosition);
      } else {
        $('html, body').animate(
          {
            scrollTop: adjustedTopPosition,
          },
          timeInMs,
          'swing'
        );
      }
    });
  };

  return this.init();
};

GeneCore.utils.anchorsUtil = $(window).anchorsUtil();

GeneCore.utils.form = {
  findInput: function (identifier, $container) {
    var selector = "[name='" + identifier + "'],#" + identifier;
    var $inputs = $container.find(selector);
    return $inputs.toArray();
  },
  getDataValueFromKey: function (data, key) {
    var dataArray = this.convertDataToArray(data);

    var matchingResultFound = false;
    for (var index in dataArray) {
      var keyValue = _.get(dataArray[index], key);

      if (keyValue) {
        matchingResultFound = keyValue;
        break;
      }
    }
    return matchingResultFound;
  },
  checkForDataValue: function (data, key, value) {
    var dataArray = this.convertDataToArray(data);
    var matchingResultFound = false;

    for (var index in dataArray) {
      var keyValue = _.get(dataArray[index], key);

      if (
        keyValue &&
        value &&
        keyValue.toString().toLowerCase() == value.toString().toLowerCase()
      ) {
        matchingResultFound = true;
        break;
      }
    }
    return matchingResultFound;
  },
  convertDataToArray: function (data) {
    if (!data) {
      return null;
    }
    var dataArray = [];
    if (data && !Array.isArray(data)) {
      dataArray.push(data);
    } else {
      dataArray = data;
    }
    return dataArray;
  },
  getSessionFormData: function () {
    var sessionData = sessionUtils.get('formSessionData');
    if (sessionData != undefined && sessionData != 'undefined') {
      sessionData = JSON.parse(sessionData);
    } else {
      sessionData = {};
    }

    return sessionData;
  },
  setSessionFormData: function (data) {
    sessionUtils.set('formSessionData', JSON.stringify(data), true);
  },
  parsleyOptions: {
    excluded:
      'input[type=button], input[type=submit], input[type=reset], input[type=hidden], [disabled], :hidden',
  },
};

$.fn.tacticCode = function () {
  //determine all possible PDFs to replace
  var pdfArray = [];
  $('[data-pdf-tactic-path]').each(function (el) {
    pdfArray.push(encodeURI($(this).data('pdf-tactic-path')));
  });

  if (pdfArray.length) {
    init();
  }

  function init() {
    var seoCouponCode = $('[data-seo-coupon-code]').data('seo-coupon-code');

    //promise for ajax response
    var promise = $.Deferred();
    promise.done(createPDFLinks);
    //still append cc selector to links so servlet applies default coupon code from metadata
    promise.fail(createPDFLinks);

    if (
      GeneCore.utils.cookieUtils.getCookie('couponCode') &&
      GeneCore.utils.generalUtils.getUrlParam('c') === undefined
    ) {
      //Coupon code is present in session cookie and no overriding tactic code parameter is in URL. Session coupon code will be used
      promise.resolve();
      return;
    }

    var tacticCode;
    if (GeneCore.utils.generalUtils.getUrlParam('c') !== undefined) {
      //a tactic code parameter is found which will result in service call to look for associated coupon code
      tacticCode = GeneCore.utils.generalUtils.getUrlParam('c');
    } else if (isSearchReferrer() && seoCouponCode) {
      //the user was referred by search engine and the authored seo coupon code should be used
      GeneCore.utils.cookieUtils.setCookie('couponCode', seoCouponCode);
      promise.resolve();
      return;
    }

    if (tacticCode) {
      $.ajax({
        type: 'GET',
        url: '/bin/gene-core/tactic-code.json?tacticCode=' + tacticCode,
        dataType: 'json',
        success: function (response) {
          if (response && response.couponCode !== null) {
            GeneCore.utils.cookieUtils.setCookie(
              'couponCode',
              response.couponCode
            );
            promise.resolve();
          } else {
            promise.reject();
          }
        },
        error: function (err) {
          //typically reached if gCampaign did not have a coupon code associated with it
          promise.reject();
        },
      });
    } else {
      //user arrived to the page without a tactic code or search engine referrer
      promise.resolve();
    }
  }

  function createPDFLinks() {
    var couponCode = GeneCore.utils.cookieUtils.getCookie('couponCode');
    $('a').each(function () {
      if ($.inArray($(this).attr('href'), pdfArray) >= 0) {
        var href = $(this).attr('href');
        var new_url = href.substring(0, href.lastIndexOf('.')) + '.cc';

        if (couponCode != null) {
          new_url += '.' + couponCode.toUpperCase();
        }
        new_url += href.substring(href.lastIndexOf('.'));
        $(this).attr('href', new_url);
      }
    });
  }

  function isSearchReferrer() {
    var searchDomains = [
        'google.com',
        'yahoo.com',
        'bing.com',
        'duckduckgo.com',
        'aol.com',
        'wow.com',
        'webcrawler.com',
        'info.com',
      ],
      length = searchDomains.length;

    while (length--) {
      if (document.referrer.indexOf(searchDomains[length]) != -1) {
        return true;
      }
    }
    return false;
  }
};

$(document).ready(function () {
  $(window).tacticCode();
});

(function ($) {
  var mocUrlName = 'moc',
    mocUrlNameAlt = 'c',
    mocCookieName = 'moc';

  var moc =
    GeneCore.utils.generalUtils.getUrlParam(mocUrlNameAlt) ||
    GeneCore.utils.generalUtils.getUrlParam(mocUrlName);

  if (moc !== null) {
    GeneCore.utils.cookieUtils.setCookie('moc', moc, null);
  }
})(jQuery);
